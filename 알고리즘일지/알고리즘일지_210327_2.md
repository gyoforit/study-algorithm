# 📝 알고리즘 일지_210327

> 백준 #16953. A -> B

## 1. 문제 분석 + 필요한 개념

- 가능한 연산은 단 두가지
- A -> B 로 바꿀 수 있다면 바꾸는데 필요한 최소 연산 +1, 바꿀 수 없다면 -1 출력



## 2. 첫 접근 방법

- 주어진 문제대로 연산해서 A가 B가 될 수 있는지 판단하기엔 경우의 수가 너무 많이 나온다고 생각했다. 각 경우 마다 1) 2를 곱하거나 2) 1을 수의 가장 오른쪽에 추가 해봐야 하니까...
- 그래서 거꾸로 B에서 A로 갈 수 있는 지의 여부를 판단하기로 했다. 즉, 1) 2로 나누거나 2) 1을 수의 가장 오른쪽에서 빼는 것이다. 이렇게 하면 조건 1의 경우 짝수일 때만, 조건 2의 경우 1이 가장 오른쪽에 붙어있을 때만 가능하므로 따져야 하는 상황이 많이 줄어든다.

## 3. 풀이

- B에서 A로 갈 수 있는 지를 판단
  - 만약 짝수라면 2로 나눈다.
  - 홀수라면 맨 끝자리가 1인지 확인
    - 끝자리가 1이면 1을 제거한다. (string 변환해서 슬라이싱한 후 다시 int로 변환)
    - 끝자리가 1이 아니면 더 이상 연산이 불가능하므로 -1을 리턴한다.
  - 연산이 진행되면 cnt(연산횟수)를 1 증가 시킨다.

```python
def calc(A, B):
    X = B
    cnt = 0
    # X가 A가 될 때까지 진행
    while A != X:
        if X < A:
            return -1
        if X % 2:
            NX = str(X)
            if NX[-1] == '1':
                X = int(NX[:-1])
            else:
                return -1
        else:
            X //= 2
        cnt += 1
    return cnt+1

A, B = map(int, input().split())
print(calc(A, B))
```



## 4. 궁금증

- 반복문으로 풀었는데 다시 보니 DFS로도 풀 수 있을 것 같다.



## 5. 배운 점

- 시작-끝, 출발-도착의 개념이 있는 문제에서는 거꾸로 생각해보는 것도 좋은 방법인 것 같다. 예전 SWEA의 사다리? 문제에서도 끝에서부터 돌아가는 방식으로 풀었던 기억이...!